package tdt4140.gr1811.app.security;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class SHA_512 {

	/**
	 * Create a SHA512 hash from a plaintext password, appending salt to end of hash
	 * delimited by {@code ':'}
	 * 
	 * @param passwordHash
	 *            the hash string, must not be null
	 * @return a hashed password including the salt in plaintext, or {@code null} if
	 *         a salt could not be generated
	 * @throws NoSuchAlgorithmException 
	 */
	public static String SHA_512_SecurePassword(String passwordHash) throws NoSuchAlgorithmException {
		String hashedPassword = null;
		byte[] salt = generateSalt();
		hashedPassword = generateHashedPassword_SHA_512(passwordHash, salt);

		// Add the salt to the end of the hash, seperate with colon
		StringBuilder sb = new StringBuilder();
		sb.append(":");
		for (int i = 0; i < salt.length; i++) {
			sb.append(Integer.toString((salt[i] & 0xff) + 0x100, 16).substring(1));
		}
		hashedPassword += sb.toString();
		return hashedPassword;
	}

	/**
	 * Using a plaintext password and a stored hash (as generated by
	 * {@link #SHA_512_SecurePassword(String)}), verifies if the password is correct
	 * 
	 * @param password
	 *            a plaintext password
	 * @param storedHash
	 *            a hash appended with salt, delimited by {@code ':'}
	 * @return {@code true} if the password was used to generate the hash
	 * @throws NoSuchAlgorithmException 
	 */
	public static boolean verifyPassword(String password, String storedHash) throws NoSuchAlgorithmException {

		String originalHash = storedHash.split(":")[0];
		char[] originalSalt_char = storedHash.split(":")[1].toCharArray();

		// Convert salt to byte array
		byte[] originalSalt = new byte[16];
		for (int i = 0, j = 0; i < originalSalt_char.length; i += 2, j++) {
			String bit_str = Character.toString(originalSalt_char[i]) + Character.toString(originalSalt_char[i + 1]);
			byte bit = (byte) ((Integer.parseInt(bit_str, 16) - 0x100) & 0xff);
			originalSalt[j] = bit;
		}

		String password_hash = generateHashedPassword_SHA_512(password, originalSalt);

		return originalHash.equals(password_hash);

	}

	/**
	 * Using a plaintext password and a salt, generates a SHA-512 hash
	 * 
	 * @param passwordToHash
	 *            the password in plaintext to be hashed, in hexadecimal
	 * @param salt
	 *            a 16-byte salt
	 * @return a hashed password, or {@code null} if the {@link MessageDigest} fails
	 *         to find a provider for the SHA-512 algorithm
	 * @throws NoSuchAlgorithmException 
	 */
	private static String generateHashedPassword_SHA_512(String passwordToHash, byte[] salt) throws NoSuchAlgorithmException {

		String generatedPassword = null;

		MessageDigest md = MessageDigest.getInstance("SHA-512");
		md.update(salt);
		byte[] bytes = md.digest(passwordToHash.getBytes());
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < bytes.length; i++) {
			sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
		}

		generatedPassword = sb.toString();

		return generatedPassword;

	}

	/**
	 * Generates a 16 byte salt using an instance of {@link SecureRandom}
	 * 
	 * @return a 16 byte salt
	 * @throws NoSuchAlgorithmException
	 *             if the SecureRandom method fails to generate the bytes
	 */
	private static byte[] generateSalt() throws NoSuchAlgorithmException {
		SecureRandom sr = new SecureRandom();
		SecureRandom.getInstance("SHA1PRNG");
		byte[] salt = new byte[16];
		sr.nextBytes(salt);
		return salt;
	}
}
